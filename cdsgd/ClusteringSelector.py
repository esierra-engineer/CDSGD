from typing import Union
from sklearn.cluster import KMeans, AgglomerativeClustering, DBSCAN
from sklearn.metrics import silhouette_score
import pandas as pd
import numpy as np


class ClusteringSelector:
    """
    ClusteringSelector is a class for selecting the best clustering algorithm
    and parameters for a given dataset.

    It evaluates and compares the performance of various clustering algorithms
    such as K-Means, Agglomerative Clustering, and DBSCAN.

    The selection is based on the silhouette score, and the class stores the
    best-performing algorithm, its parameters, and the resulting cluster
    labels.

    Attributes:
        data (pd.DataFrame): The dataset on which clustering algorithms will
                             be applied.
        best_algorithm (str): Name of the best-performing clustering algorithm.
        best_params (list): Parameters of the best-performing clustering
                            algorithm.
        best_labels (np.array): Cluster labels generated by the
                                best-performing algorithm.
        cluster (int, optional): Number of clusters to be used, if specified.
        kmeans_labels (np.array): Labels generated by the K-Means algorithm.
        agglomerative_labels (np.array): Labels generated by the Agglomerative
                                         Clustering algorithm.
        dbscan_labels (np.array): Labels generated by the DBSCAN algorithm.
        best_score_total (float): Highest silhouette score achieved among all
                                  algorithms.
        linkage_values (list): Different linkage methods to be tested with
                               Agglomerative Clustering.
        eps_values (list): Different 'eps' values to be tested with DBSCAN.
        min_samples_values (list): Different 'min_samples' values to be tested
                                   with DBSCAN.
        n_clusters_values (list): Different numbers of clusters to be tested.
    """
    def __init__(self, data: pd.DataFrame, cluster:  Union[int, None] = None):
        self.data = data
        self.best_algorithm = None
        self.best_params = [0]*5
        self.best_labels = None
        self.cluster = cluster
        self.kmeans_labels = None
        self.agglomerative_labels = None
        self.dbscan_labels = None
        self.best_score_total = float('-inf')
        self.linkage_values = ['ward', 'complete', 'average']
        self.eps_values = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]
        self.min_samples_values = [2, 3, 4, 5, 6]
        self.n_clusters_values = ([2, 3, 4] if self.cluster is None
                                  else [self.cluster])

    def select_best_clustering(self):
        """
        Evaluates and selects the best clustering algorithm for the dataset.
        This method tests K-Means, Agglomerative Clustering, and DBSCAN with
        various parameters, comparing their performance using the silhouette
        score.
        The method updates the class attributes with the best-performing
        algorithm's name, parameters, and labels.
        """
        # Test Parameters
        best_score_dbscan = float('-inf')
        best_score_kmeans = float('-inf')
        best_score_aggclust = float('-inf')

        for n_clusters in self.n_clusters_values:
            # K-Means
            kmeans = KMeans(n_clusters=n_clusters, random_state=42)
            kmeans_labels = kmeans.fit_predict(self.data)
            # Calculate metrics
            kmeans_silhouette = (silhouette_score(self.data, kmeans_labels)
                                 if len(set(kmeans_labels)) > 2 else 0)
            kmeans_score = kmeans_silhouette

            # Comparation of the score
            if kmeans_score > best_score_kmeans:
                self.best_params[0] = n_clusters
                best_score_kmeans = kmeans_score
                self.kmeans_labels = kmeans_labels

            for linkage in self.linkage_values:
                # Agglomerative Clustering
                aggclust = AgglomerativeClustering(n_clusters=n_clusters,
                                                   linkage=linkage)
                aggclust_labels = aggclust.fit_predict(self.data)

                # Calculate metrics
                aggclust_silhouette = (silhouette_score(self.data,
                                                        aggclust_labels)
                                       if len(set(aggclust_labels)) > 2
                                       else 0)
                aggclust_score = aggclust_silhouette

                if aggclust_score > best_score_aggclust:
                    best_score_aggclust = aggclust_score
                    self.best_params[1] = n_clusters
                    self.best_params[2] = linkage
                    self.agglomerative_labels = aggclust_labels

        for eps in self.eps_values:
            for min_samples in self.min_samples_values:
                # DBSCAN
                dbscan = DBSCAN(eps=eps, min_samples=min_samples)
                dbscan_labels = dbscan.fit_predict(self.data)

                # Calculate metrics
                silhouette = (silhouette_score(self.data, dbscan_labels)
                              if len(set(dbscan_labels)) > 2 else 0)
                dbscan_score = silhouette
                if dbscan_score > best_score_dbscan:
                    self.best_params[3] = eps
                    self.best_params[4] = min_samples
                    best_score_dbscan = dbscan_score
                    self.dbscan_labels = dbscan_labels

        if kmeans_score > self.best_score_total:
            self.best_score_total = kmeans_score
            self.best_algorithm = "K-Means"
            self.best_labels = kmeans_labels

        if aggclust_score > self.best_score_total:
            self.best_score_total = aggclust_score
            self.best_algorithm = "Agglomerative Clustering"
            self.best_labels = aggclust_labels

        if dbscan_score > self.best_score_total and self.cluster is None:
            self.best_score_total = dbscan_score
            self.best_algorithm = "DBSCAN"
            self.best_labels = dbscan_labels

        if self.best_algorithm == "DBSCAN":
            clusters = max(self.best_labels) + 1
            # Since the classifier does not work with negative classes,
            # it is necessary to adjust the labels that do not belong to any
            # cluster and are labeled as the last cluster.
            self.best_labels[self.best_labels == -1] = clusters

    def normalize_labels(self, x, y):
        """
        Normalizes or standardizes clustering labels.
        This method might be used to adjust labels to a common scale or format.

        Parameters:
            labels (np.array): Array of cluster labels to be normalized.

        Returns:
            np.array: Normalized or standardized labels.
        """
        labels1 = x
        labels2 = y
        # Create an array to save the updated values of the second array
        updated_labels2 = np.copy(labels2)

        # Create a dicctionary to save the correspondances of the labels
        correspondence_dict = {}

        for label1, label2 in zip(labels1, labels2):
            if label1 != label2:
                if label1 not in correspondence_dict:
                    correspondence_dict[label1] = label2

        # Update the values of the second array
        for old_label, new_label in correspondence_dict.items():
            updated_labels2[labels2 == new_label] = old_label

        return updated_labels2

    def get_cluster_labels_df(self):
        """
        Creates a DataFrame containing the cluster labels from each tested
        clustering algorithm.
        The labels are normalized based on the best-performing algorithm.

        Returns:
            pd.DataFrame: A DataFrame with columns for each clustering
                          algorithm's labels.
        """
        labels_df = pd.DataFrame(
            {"K-Means Labels": (self.best_labels
                                if self.best_algorithm == "K-Means"
                                else self.normalize_labels(self.best_labels,
                                                           self.kmeans_labels)
                                ),
             "Agglomerative Labels": (self.best_labels
                                      if self.best_algorithm ==
                                      "Agglomerative Clustering"
                                      else
                                      self.normalize_labels(
                                        self.best_labels,
                                        self.agglomerative_labels)),
             "DBSCAN Labels": (self.best_labels
                               if self.best_algorithm == "DBSCAN"
                               else self.normalize_labels(self.best_labels,
                                                          self.dbscan_labels))
             })
        return labels_df

    def get_best_labels(self):
        """
        Returns the best cluster labels determined by the best-performing
        algorithm.

        Returns:
            np.array: The best cluster labels.
        """
        return self.best_labels

    def get_best_params(self):
        """
        Returns the parameters of the best-performing clustering algorithm.

        Returns:
            list: Parameters of the best-performing algorithm.
        """
        return self.best_params

    def get_best_name(self):
        """
        Returns the name of the best-performing clustering algorithm.

        Returns:
            str: Name of the best-performing algorithm.
        """
        return self.best_algorithm

    def get_most_voted(self):
        """
        Determines the most common label for each data point across different
        clustering algorithms.

        In cases of NaN values, replaces them with labels from the
        best-performing algorithm.

        Returns:
            np.array: Array of the most common labels for each data point.
        """
        labels_df = self.get_cluster_labels_df()
        row_modes = labels_df.mode(axis=1)
        not_nan_index = row_modes.index[~row_modes.isna().any(axis=1)]
        for x in not_nan_index:
            row_modes[0][x] = self.get_best_labels()[x]

        return np.array(row_modes[0])
